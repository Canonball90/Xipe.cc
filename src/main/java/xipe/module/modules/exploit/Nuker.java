package xipe.module.modules.exploit;

import xipe.module.Mod;
import xipe.module.settings.NumberSetting;
import xipe.utils.player.RotationUtils;
import xipe.utils.render.RenderUtils;

import java.util.Iterator;
import java.awt.Color;
import net.minecraft.util.math.Box;
import net.minecraft.client.util.math.MatrixStack;
import net.minecraft.block.BlockState;
import net.minecraft.util.math.Direction;
import net.minecraft.block.Blocks;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.math.Vec3i;
import java.util.ArrayList;
import net.minecraft.util.math.BlockPos;
import java.util.List;

public class Nuker extends Mod
{
    final List<BlockPos> renders;
    public NumberSetting radius;
    public NumberSetting delay;
    public NumberSetting r;
    public NumberSetting g;
    public NumberSetting b;
    int delayTicks;
    public Color color;
    
    public Nuker() {
        super("Nuker", "Automatically breaks block arround you", Category.WORLD);
        this.renders = new ArrayList<BlockPos>();
        this.radius = new NumberSetting("Radius", 0.0, 6.0, 5.0, 1.0);
        this.delay = new NumberSetting("Delay", 0.0, 100.0, 0.0, 1.0);
        this.r = new NumberSetting("Red", 0.0, 255.0, 0.0, 1.0);
        this.g = new NumberSetting("Green", 0.0, 255.0, 0.0, 1.0);
        this.b = new NumberSetting("Blue", 0.0, 255.0, 0.0, 1.0);
        this.delayTicks = 0;
        this.addSettings(this.radius, this.delay, this.r, this.g, this.b);
    }
    
    @Override
    public void onTick() {
        final BlockPos ppos1 = this.mc.player.getBlockPos();
        this.renders.clear();
        for (double y = this.radius.getValue(); y > -this.radius.getValue() - 1.0; --y) {
            for (double x = -this.radius.getValue(); x < this.radius.getValue() + 1.0; ++x) {
                for (double z = -this.radius.getValue(); z < this.radius.getValue() + 1.0; ++z) {
                    final BlockPos vp = new BlockPos(x, y, z);
                    final BlockPos np = ppos1.add((Vec3i)vp);
                    final Vec3d vp2 = new Vec3d((double)np.getX(), (double)np.getY(), (double)np.getZ());
                    if (vp2.distanceTo(this.mc.player.getPos()) < this.mc.interactionManager.getReachDistance() - 0.2) {
                        final BlockState bs = this.mc.world.getBlockState(np);
                        if (!bs.isAir() && bs.getBlock() != Blocks.WATER && bs.getBlock() != Blocks.LAVA && bs.getBlock() != Blocks.BEDROCK && this.mc.world.getWorldBorder().contains(np) && this.delayTicks <= 0) {
                            this.renders.add(np);
                            this.mc.interactionManager.updateBlockBreakingProgress(np, Direction.DOWN);
                            RotationUtils.setSilentYaw((float)RotationUtils.getYaw(np));
                            RotationUtils.setSilentPitch((float)RotationUtils.getPitch(np));
                            this.delayTicks = (int)this.delay.getValue();
                        }
                        if (this.delayTicks > 0) {
                            --this.delayTicks;
                        }
                    }
                }
            }
        }
        super.onTick();
    }
    
    @Override
    public void onDisable() {
        RotationUtils.resetYaw();
        RotationUtils.resetPitch();
        super.onDisable();
    }
    
    @Override
    public void onWorldRender(final MatrixStack matrices) {
    	this.color = new Color(r.getValueInt(),g.getValueInt(),b.getValueInt(), 255);
        for (final BlockPos pos : this.renders) {
            final Vec3d render = RenderUtils.getRenderPosition(pos);
            RenderUtils.drawOutlineBox(matrices, new Box(render.x, render.y, render.z, render.x + 1.0, render.y + 1.0, render.z + 1.0), color, true);
        }
        super.onWorldRender(matrices);
    }
}
